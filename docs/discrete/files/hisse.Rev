#############################################################################
#
# HiSSE
#
# authors: Rosana Zenil-Ferguson
# last modified: 05/25/2025
################################################################################

#######################
# Numero de estados y de tasas #
#######################
NUM_STATES = 2
NUM_HIDDEN = 2
NUM_RATES = NUM_STATES * NUM_HIDDEN


# Proposals (moves), and monitors vectors
moves = VectorMoves()
monitors = VectorMonitors()

#########################
# Reading the data
#########################
### Phylogenetic tree
observed_phylogeny <- readTrees("poliniza_arbol.tre")[1]


## Data
## 0 = Insect
## 1 = Wind
data <- readCharacterDataDelimited("poliniza_datos.csv",
stateLabels=2,
type="NaturalNumbers",
delimiter=",",
header=TRUE)

# Expand 0 and 1 to have A and B hidden states
data_exp <- data.expandCharacters( NUM_HIDDEN )

# How many taxa
taxa <- observed_phylogeny.taxa()

### How old is the phylogenetic tree?
root_age <- observed_phylogeny.rootAge()


#########################################################
# Transition rates #
#########################################################
###### This is the version of RZF that allows for more flexibility in the transition rates both for main states and hidden states

## Definir unas Gamas a priori con mucha incertidumbre
shape_pr := 0.5
rate_pr := observed_phylogeny.treeLength()/5

#### Crea una matriz de 4x4 porque son 4 estados
for (i in 1:NUM_RATES) {
for (j in 1:NUM_RATES) {
q[i][j] := 0.0
}
}

#La manera en que se esta definiendo en RevBayes los estados son 1=0A, 2=1A, 3=0B, and 4=1B
q_01A ~ dnGamma(shape=shape_pr, rate=rate_pr)
moves.append(mvScale(q_01A, weight=2 ))
q_10A ~ dnGamma(shape=shape_pr, rate=rate_pr)
moves.append(mvScale(q_10A, weight=2 ))
q_01B ~ dnGamma(shape=shape_pr, rate=rate_pr)
moves.append(mvScale(q_01B, weight=2 ))
q_10B ~ dnGamma(shape=shape_pr, rate=rate_pr)
moves.append(mvScale(q_10B, weight=2 ))
q[1][2] :=q_01A
q[3][4] :=q_01B
q[2][1] :=q_10A
q[3][4] :=q_10B

#########################################################
# Hidden state transitions #
#########################################################
# We use an exponential as a prior
hidden_rate1 ~ dnExponential(rate_pr)
moves.append(mvScale(hidden_rate1,lambda=0.2,tune=true,weight=2))
hidden_rate2 ~ dnExponential(rate_pr)
moves.append(mvScale(hidden_rate2,lambda=0.2,tune=true,weight=2))
#### Las tasas aqui van (alpha,beta, alpha, beta)
q[1][3] := hidden_rate1
q[2][4] := hidden_rate1
q[3][1] := hidden_rate2
q[4][2] := hidden_rate2
### Nota aqui se podrian definir cuatro tasas, pero se complica mucho

######################################################################
# Creating the Q-matrix for the transitons #
######################################################################
rate_matrix := fnFreeK(q, rescaled=false, matrixExponentialMethod="scalingAndSquaring")

#####################################

####################
#Diversification rates #
####################

### Specify a prior on the diversification

### Create the constant prior parameters of the diversification rates

H = 0.5
rate_mean <- ln(ln(103/2.0) /root_age) # Magallon and Sanderson (2001)
rate_sd <- 2*H

##We will be careful for the diversification rates of 0A y 0B. We will use a multiplier called sepciation_alpha for states in A and speciation_alpha+speciation_beta for B. We build them this way because A and B are hidden states derivated from the same main state so in theory they should be not so different. However, you can decide to define them separatedly.


for (i in 1:NUM_STATES) {
### Create a lognormal distributed variable for the speciation rate
speciation_alpha[i] ~ dnNormal(mean=rate_mean,sd=rate_sd)
moves.append(mvSlide(speciation_alpha[i],delta=0.20,tune=true,weight=2.0))

### Create a lognormal distributed variable for the extinction rate
extinction_alpha[i] ~ dnNormal(mean=rate_mean,sd=rate_sd)
moves.append(mvSlide(extinction_alpha[i],delta=0.20,tune=true,weight=2.0))
}


for (i in 1:NUM_HIDDEN) {

### Create an exponential distributed variable for the speciation rate
speciation_beta[i] ~ dnExp(1.0)
moves.append(mvScale(speciation_beta[i],lambda=0.20,tune=true,weight=2.0))

### Create an normal distributed variable for the extinction
extinction_beta[i] ~ dnNormal(0.0,1.0)
moves.append(mvSlide(extinction_beta[i],delta=0.20,tune=true,weight=2.0))

}

for (j in 1:NUM_HIDDEN) {
for (i in 1:NUM_STATES) {
if ( j == 1) {
speciation[i] := exp( speciation_alpha[i] )
extinction[i] := exp( extinction_alpha[i] )
} else {
index = i+(j*NUM_STATES)-NUM_STATES
speciation[index] := exp( speciation_alpha[i] + speciation_beta[j-1] )
extinction[index] := exp( extinction_alpha[i] + extinction_beta[j-1] )
}
}
}



# Set up the root state frequencies #
#####################################

### Create a constant variable with the prior probabilities of each rate category at the root.
root_frequencies ~ dnDirichlet(  rep(1,NUM_RATES) )
moves.append(mvDirichletSimplex(root_frequencies,tune=true,weight=2))


### Sampling fraction
rho <- 103/200


####################################################################
# dnCDBDP= The model
###################################################################

### Here is where I tie speciation, extinction, and Q using a Birth-Death with categories

hisse ~ dnCDBDP( rootAge = root_age,
speciationRates   = speciation,
extinctionRates   = extinction,
Q                 = rate_matrix,
pi                = root_frequencies,
rho               = rho,
delta             = 1,
condition         = "time")

### clamp the model with the "observed" tree
hisse.clamp( observed_phylogeny )
hisse.clampCharData( data_exp ) #note the clamping on the expanded dataset

#############
# The Model #
#############


### workspace model wrapper ###
mymodel = model(rate_matrix)

### set up the monitors that will output parameter values to file and screen
monitors.append(mnModel(filename="output/hisse_pollination.log", printgen=1))
monitors.append(mnJointConditionalAncestralState(tree=hisse cdbdp=timetree, type="NaturalNumbers", printgen=1000, withTips=true, withStartStates=false, filename="output/anc_states_hisse_pollination.log"))
monitors.append(mnScreen(printgen=10, q_01A, q_10A, speciation, extinction))


###############
# The MCMC#
################

### Creating the MCMC object
mymcmc = mcmc(mymodel, monitors, moves, nruns=2, moveschedule="random")

### pre-burnin to tune the proposals 20% of the sample
#mymcmc.burnin(generations=2000,tuningInterval=100)

### run the MCMC
mymcmc.run(generations=150000)


### Opcional reconstruccion ancestral
###anc_state_trace = readAncestralStateTrace("output/anc_states_hisse_pollination_run_1.log")
###ancestralStateTree(tree=observed_phylogeny, ancestral_state_trace_vector=anc_state_trace, include_start_states=false, file="output/asr_hisse_polinizador.tree", summary_statistic="MAP", reconstruction="marginal")

q()



