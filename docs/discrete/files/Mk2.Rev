#########################################################################################################
#########################################################################################################
#
## Mk2: A model for pollinization
##
## Autor: Rosana Zenil-Ferguson
## Last update: RZF 05/29/2025
#########################################################################################################


# Number of states
NUM_STATES=2

# Proposals (moves), Monitors(follow the inference from the MCMC)
moves = VectorMoves()
monitors = VectorMonitors()

#########################
# Reading your data
#########################
### Phylogeny
observed_phylogeny <- readTrees("data/poliniza_arbol.tre")[1]


## Data
## 0 = Insect
## 1 = Wind
data <- readCharacterDataDelimited("data/poliniza_datos.csv",
stateLabels=2,
type="NaturalNumbers",
delimiter=",",
header=TRUE)

taxa <- observed_phylogeny.taxa()

#### Prior distribution for transition rates

shape_pr := 0.5
rate_pr = observed_phylogeny.treeLength()/5

q_01 ~ dnGamma(shape=shape_pr, rate=rate_pr) ### Insect to Wind
q_10 ~ dnGamma(shape=shape_pr, rate=rate_pr) ### Wind to insect

# We start storing the proposals for each parameter. These represent how we are going to explore the parameter space
moves.append(mvScale( q_01, weight=2 ))
moves.append(mvScale( q_10, weight=2 ))

### Building the Q-matrix for the Mk2.
#First start with a matrix full of zeros
for (i in 1:2){
for (j in 1:2){
        q[i][j]:= 0.0
    }
}
#### Then start filling the matrix
q[1][2] := q_01
q[2][1] := q_10


# The Q-matrix is an infinitesimal matrix, meaning it is a derivative of the probability matrix.

rate_matrix := fnFreeK(q, rescaled=false, matrixExponentialMethod="scalingAndSquaring")

# The root values are an unknown but random variable that we need to estimate. This is different from many assumptions done in R packages.

root_frequencies ~ dnDirichlet(rep(1,NUM_STATES))

# Proposals to move the value of the root

moves.append(mvBetaSimplex(root_frequencies, alpha=0.5, weight=2))

moves.append(mvElementSwapSimplex(root_frequencies, weight=3))

# The Mk2 model has an stochastic phylogenetic distribution called PhyloCTMC (phylogenetic continuous time markov chain)

ctmc ~ dnPhyloCTMC(Q= rate_matrix, tree=observed_phylogeny, nSites=1, rootFreq=root_frequencies, type="NaturalNumbers")

#Fix our observations to our stochastic model
ctmc.clamp(data)


#########################
# MCMC - The algorithm that allows us to do inference
#########################

# mymodel is a "box" that stores the whole graphical model properties
mymodel = model(rate_matrix)


# Monitors follow the inference, if you don't save monitors you don't get inferences

# This monitor saves the posterior and it is the most important to save
monitors.append(mnModel(filename="output/mk2_polinizador.log", printgen=1))

## This monitor prints in screen so you know something is happening. It also gives you an ETA for finalizing inference
monitors.append(mnScreen(printgen=10,q_01))

## This monitor saves the ancestral state reconstructions
monitors.append(mnJointConditionalAncestralState(filename="output/asr_mk2_polinizador.log",printgen=100,tree=observed_phylogeny,ctmc=ctmc,type="NaturalNumbers"))

## This monitor saves the stochastic map
monitors.append( mnStochasticCharacterMap(ctmc=ctmc,printgen=100,filename="output/stochmap_mk2_polinizador.log", include_simmap=true))

#### We always run TWO times our MCMC at the very least to check for convergence

mymcmc = mcmc(mymodel, monitors, moves, nruns=2, moveschedule="random")
mymcmc.run(50000)


#########################
# Creating the summaries of ancestral state reconstruction
#########################

# Once we have the ancestral state reconstruction runs we read them
anc_state_trace = readAncestralStateTrace("output/asr_mk2_polinizador_run_1.log")

# Then summarize them using the MARGINAL of JOINT
ancestralStateTree(tree=observed_phylogeny,ancestral_state_trace_vector=anc_state_trace, include_start_states=false, file="output/sr_mk2_polinizador.tree", summary_statistic="MAP", reconstruction="marginal")

# Summarize stochastic maps (but we will do it again in R through revgadets so not as critical)
#anc_state_trace = readAncestralStateTrace("output/stochmap_mk2_polinizador_run_1.log")
#characterMapTree(observed_phylogeny, anc_state_trace, character_file="output/stochmap_mk2_polinizador.tree", posterior_file="output/posteriorpole.tree", burnin=50, reconstruction="marginal")
q()

